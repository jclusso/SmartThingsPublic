/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() {
    return "03.05.00"
}

/**
* User Door Unlock/Lock Notifications and Actions. Mirror of Multi User Lock Code Mgmt without the code programming, reuse existing lock programming
*
* Copyright RBoy Apps
* Redistribution of code is not allowed without permission
*
* Change Log:
* 2017-5-31 - (v03.05.00) Improved deadbolt automatic unlocking for Schlage locks, added support for playing back on audio systems, added support for bluetooth
* 2017-5-29 - (v03.04.03) Bugfix for unlocking and locking without codes throwing an error
* 2017-5-26 - (v03.04.02) Due to ST phone changes, now separate multiple SMS numbers with a *
* 2017-4-19 - (v03.04.01) Patch for reporting Master Codes
* 2017-4-11 - (v03.04.00) Added ability to select Chimes for when doors are opened and closed, improved user interface/text, added user presence based notifications
* 2017-4-11 - (v03.03.01) Fixed grammar for messages
* 2017-1-25 - (v3.3.0) Added ability to run lock/unlock actions on when the specified users aren't present or not in specific modes, also less verbose messages unless detailed notifications are enabled while running lock and unlock actions
* 2017-1-12 - (v3.2.2) Added ability to report and run actions on unknown users (some locks don't report use code when unlocking via keypad) and master codes
* 2016-11-14 - Improved code update checks and now use ; instead of + for separating multiple SMS numbers
* 2016-10-30 - Fixed an issue with notifications not working and added code update notifications
* 2016-9-26 - Fix for broken ST phrases returning null data
* 2016-9-17 - Fixed issue with cannot change notify settings, highlight error messages, improved invalid date checks, code clean up
* 2016-9-16 - Fix for actions page not showing up when there are no routines defined on the hub
* 2016-9-16 - Patch for broken HREF pages in ST app 2.2.0
* 2016-9-13 - Bug fix when mode changes and no sensor is defined for door
* 2016-9-7 - Auto locks and open door notifications will engage if requried when mode changes
* 2016-9-2 - Added ability to specify modes of operations for auto door lock
* 2016-8-30 - Fixed bug with disable all push notifications, it should not disable text notifications and should only work when there is no contact address book
* 2016-8-17 - Added workaround for ST contact address book bug
* 2016-8-6 - Added support to auto relock door if the door hasn't been opened after specified timeout
* 2016-8-5 - Fix for autoRelock and openDoor notifications errors when using large timeout values
* 2016-7-25 - Added support for working with RFID cards
* 2016-7-22 - Added support for contact address book for customers who have this feature enabled
* 2016-7-19 - Updated code to use harmonized universal DH with type event instead of outsideLockEvent
* 2016-7-17 - Improvement to the unlocking and relocking logic
* 2016-7-17 - Workaround for platform calling installed and updated when installing the SmartApp
* 2016-7-17 - Put in a check to not enable automatic unlock if autolock in the door is enabled
* 2016-7-14 - Improved notifications
* 2016-7-13 - Added support for tamper events and when using user codes to lock the door from the keypad
* 2016-7-10 - Added support for running routine when the door is locked using external keypad lock button
* 2016-7-5 - Added support for notifications if door is left open, added support for delayed relock for multiple door and various minor UI improvements
* 2016-7-5 - Added client version on main page
* 2016-4-8 - Added support for notification modes for unlocking (and improved UI)
* 2016-4-8 - Bugfix for jammed and manual lock notifications not coming
* 2016-2-20 - Added slot notification for unknown users 
* 2016-2-7 - Revamped from scratch
*
*/
definition(
    name: "User Unlock/Lock Door Notifications and Actions",
    namespace: "rboy",
    author: "RBoy Apps",
    description: "Execute actions when users unlock/lock doors",
    category: "Safety & Security",
    iconUrl: "https://s3.amazonaws.com/smartapp-icons/Solution/doors-locks-active.png",
    iconX2Url: "https://s3.amazonaws.com/smartapp-icons/Solution/doors-locks-active@2x.png"
)

import groovy.json.JsonSlurper

preferences {
    page(name: "setupApp")
    page(name: "usersPage")
    page(name: "unlockLockActionsPage")
    page(name: "relockDoorPage")
}

def setupApp() {
    log.trace "$settings"

    dynamicPage(name: "setupApp", title: "User Door Unlock/Lock Notifications and Actions v${clientVersion()}", install: false, uninstall: true, nextPage: "usersPage") {    
        section("Select Lock(s)") {
            input "locks","capability.lock", title: "Lock", multiple: true, submitOnChange: true
        }

		section("How many Users do you want to monitor (common to all selected locks)?") {
        	input name: "maxUserNames", title: "Max users", type: "number", required: true, multiple: false
        }

        section("General Settings") {
            // Unlock actions for all users (global)
            def hrefParams = [
                user: null, 
                passed: true 
            ]
            href(name: "unlockActions", params: hrefParams, title: "Click here to define general actions and notifications when doors are locked/unlocked by users", page: "unlockLockActionsPage", description: "", required: false)
            href(name: "relockDoor", title: "Click here to define actions and notifications when doors are opened/closed", page: "relockDoorPage", description: "", required: false)

            input("recipients", "contact", title: "Send notifications to", multiple: true, required: false) {
                paragraph "You can enter multiple phone numbers to send an SMS to by separating them with a '*'. E.g. 5551234567*+448747654321"
                input name: "sms", title: "Send SMS notification to (optional):", type: "phone", required: false
                paragraph "Enable the below option if you DON'T want push notifications on your SmartThings phone app."
                input name: "disableAllNotify", title: "Disable all push notifications", type: "bool", defaultValue: "false", required: true
            }
            input name: "audioDevices", title: "Play notifications on these devices", type: "capability.audioNotification", required: false, multiple: true
        }

        section() {
            label title: "Assign a name for this SmartApp (optional)", required: false
            input name: "disableUpdateNotifications", title: "Don't check for new versions of the app", type: "bool", required: false
        }
    }
}

def relockDoorPage() {
    dynamicPage(name:"relockDoorPage", title: "Select door open/close sensor for each door and configure the automatic unlock, relock and notifications of the door", uninstall: false, install: false) {
        section {
            for (lock in locks) {
                def priorRelockDoor = settings."relockDoor${lock}"
                def priorRelockImmediate = settings."relockImmediate${lock}"
                def priorRelockAfter = settings."relockAfter${lock}"
                def priorRetractDeadbolt = settings."retractDeadbolt${lock}"
                def priorNotifyOpen = settings."openNotify${lock}"
                def priorNotifyOpenTimeout = settings."openNotifyTimeout${lock}"
                def priorOpenNotifyModes = settings."openNotifyModes${lock}"
                def priorRelockDoorModes = settings."relockDoorModes${lock}"
                def priorNotifyBeep = settings."openNotifyBeep${lock}"

                paragraph "\r\n"
                paragraph title: "Configure ${lock}", required: true, ""
                if (priorRelockDoor || priorRetractDeadbolt || priorNotifyOpen || priorNotifyBeep) {
                    input "sensor${lock}", "capability.contactSensor", title: "Door open/close sensor", required: true
                }

                input name: "relockDoor${lock}", type: "bool", title: "Relock door automatically after closing", defaultValue: priorRelockDoor, required: true, submitOnChange: true
                if (priorRelockDoor) {
                    input name: "relockImmediate${lock}", type: "bool", title: "Relock immediately", defaultValue: priorRelockImmediate, required: true, submitOnChange: true
                    if (!priorRelockImmediate) {
                        input name: "relockAfter${lock}", type: "number", title: "Relock after (minutes)", defaultValue: priorRelockAfter, required: true                   
                    }
                    input name: "relockDoorModes${lock}", type: "mode", title: "...only when in this mode(s) (optional)", defaultValue: priorRelockDoorModes, required: false, multiple: true
                }

                paragraph "Use this if you want to automatically retract the deadbolt (unlock) if it accidentally extends (locks) while the door is still open. This can avoid damage to the door frame.\nNOTE: Make sure the AutoLock feature on the lock has been disabled to use this feature otherwise it can go an infinite loop of locking/unlocking."
                input name: "retractDeadbolt${lock}", type: "bool", title: "Unlock door if locked while open", defaultValue: priorRetractDeadbolt, required: true, submitOnChange: true

                paragraph "Select the chime to ring when the door has been opened.\r\n(Optionally) Get a notification if the door has been left open for too long."
                input name: "openNotifyBeep${lock}", type: "capability.tone", title: "Ring this Chime when door is opened", multiple: true, required: false, submitOnChange: true
                input name: "openNotify${lock}", type: "bool", title: "Notify if door has been left open for too long", defaultValue: priorNotifyOpen, required: true, submitOnChange: true
                if (priorNotifyOpen) {
                    input name: "openNotifyTimeout${lock}", type: "number", title: "...for (minutes)", defaultValue: priorNotifyOpenTimeout, required: true, range: "1..*"
                }
                if (priorNotifyOpen || priorNotifyBeep) {
                    input name: "openNotifyModes${lock}", type: "mode", title: "...only when in this mode(s) (optional)", defaultValue: priorOpenNotifyModes, required: false, multiple: true
                }
            }
        }
    }
}

def unlockLockActionsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = ""
    // Get user from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.user) {
        user = params.user
        log.trace "Passed from main page, using params lookup for user $user"
    } else if (atomicState.params) {
        user = atomicState.params.user ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for user $user"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    def name = user ? settings."userNames${user}" : ""

    log.trace "Unlock Action Page, user:$user, name:$name, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"unlockLockActionsPage", title: "Setup lock/unlock actions for each door" + (user ? " for user $name." : ""), uninstall: false, install: false) {
        def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines
        def showActions = true
        if (!phrases) {
            log.warn "No Routines found!!!"
        }
        section {
            if (user) { // User specific override options
                paragraph "Enabling user specific actions and notifications will override over the general actions defined on the first page"
                input "userOverrideUnlockActions${user}", "bool", title: "Define specific actions for $name", required: true,  submitOnChange: true
                if (!settings."userOverrideUnlockActions${user}") { // Check if user has enabled specific override actions then show menu
                    showActions = false
                }
            }
            if  (showActions && locks?.size() > 1) {
                input "individualDoorActions${user}", "bool", title: "Separate actions for each door", required: true,  submitOnChange: true
            }
        }
        if (showActions) { // Do we need to show actions?
            if (settings."individualDoorActions${user}") {
                for (lock in locks) {
                    section() {
                        paragraph title: "$lock Lock/Unlock Actions", required: true, ""
                    }

                    section ("Door Unlock Actions for $lock (optional)") {
                        def priorHomePhrase = settings."homePhrase${lock}${user}"
                        def priorHomeMode = settings."homeMode${lock}${user}"
                        def priorHomeDisarm = settings."homeDisarm${lock}${user}"
                        def priorLockPhrase = settings."externalLockPhrase${lock}${user}"
                        def priorManualNotify = settings."manualNotify${lock}"

                        paragraph "Run these routines and/or change the mode when a user successfully unlocks the door $lock"
                        input "homePhrase${lock}${user}", "enum", title: "Run Routine", required: false, options: phrases, defaultValue: priorHomePhrase
                        input "homeMode${lock}${user}", "mode", title: "Change Mode To", required: false, multiple: false, defaultValue: priorHomeMode
                        input "homeDisarm${lock}${user}", "bool", title: "Disarm Smart Home Monitor", required: false, defaultValue: priorHomeDisarm

                        paragraph "Turn on these lights after dark when a user successfully unlocks the door $lock"
                        input "turnOnSwitchesAfterSunset${lock}${user}", "capability.switch", title: "Turn on light(s) after dark", required: false, multiple: true

                        paragraph "Turn on and/or off these switches/lights when a user successfully unlocks the door $lock"
                        input "turnOnSwitches${lock}${user}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
                        input "turnOffSwitches${lock}${user}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true

                        paragraph title: "Do NOT run the above unlock actions for door $lock under any of the following conditions", required: true, ""
                        input "runXPeopleUnlockActions${lock}${user}", "capability.presenceSensor", title: "...when any these people are present", required: false, multiple: true
                        input "runXModeUnlockActions${lock}${user}", "mode", title: "...when in any of these mode(s)", required: false, multiple: true

                        if (!user) { // Users will use the user notify option
                            paragraph "Get notifications when the door is unlocked manually (inside or outside)"
                            input "manualNotify${lock}", "bool", title: "Notify on manual unlock", submitOnChange: true
                            if (priorManualNotify) {
                                input "manualNotifyModes${lock}", "mode", title: "Only when in this mode(s) (optional)", required: false, multiple: true
                            }
                        }
                    }

                    section("Door Lock Actions for $lock (optional)") {
                        if (lock.hasAttribute('invalidCode')) { // For now only custom DH supports lock codes
                            paragraph "Some locks (e.g. Schlage/Yale) can be locked from the keypad outside${user ? " with user codes" : ""}. If your lock has his feature then you can assign routines to execute when it is locked ${user ? "with a user code" : "from the keypad"}"
                            input "externalLockPhrase${lock}${user}", "enum", title: "Run routine on user lock", required: false, options: phrases, defaultValue: priorLockPhrase
                            if (!user) { // Users will use the user notify option
                                input "externalLockNotify${lock}", "bool", title: "Notify on keypad lock", submitOnChange: true
                                if (settings."externalLockNotify${lock}") {
                                    input "externalLockNotifyModes${lock}", "mode", title: "Only when in this mode(s) (optional)", required: false, multiple: true
                                }
                            }
                            paragraph title: "Do NOT run the above lock actions for door $lock under any of the following conditions", required: true, ""
                            input "runXPeopleLockActions${lock}${user}", "capability.presenceSensor", title: "...when any these people are present", required: false, multiple: true
                            input "runXModeLockActions${lock}${user}", "mode", title: "...when in any of these mode(s)", required: false, multiple: true
                        } else {
                            paragraph title: "Use the Enhanced Z-Wave Lock device handler to get access to lock specific actions", required: true, ""
                        }

                        if (!user) { // Users will use the user notify option
                            paragraph "Get notifications when the door is locked (manually or automatically)"
                            input "lockNotify${lock}", "bool", title: "Notify on manual lock", submitOnChange: true
                            if (settings."lockNotify${lock}") {
                                input "lockNotifyModes${lock}", "mode", title: "Only when in this mode(s) (optional)", required: false, multiple: true
                            }

                            input "jamNotify${lock}", "bool", title: "Notify on Lock Jam/Stuck"
                        }
                    }
                }
            } else {
                section("Door Unlock Actions (optional)") {
                    paragraph "Run these routines and/or change the mode when a user successfully unlocks the door"
                    input "homePhrase${user}", "enum", title: "Run Routine", required: false, options: phrases
                    input "homeMode${user}", "mode", title: "Change Mode To", required: false, multiple: false
                    input "homeDisarm${user}", "bool", title: "Disarm Smart Home Monitor", required: false

                    paragraph "Turn on these lights after dark when a user successfully unlocks the door"
                    input "turnOnSwitchesAfterSunset${user}", "capability.switch", title: "Turn on light(s) after dark", required: false, multiple: true

                    paragraph "Turn on and/or off these switches/lights when a user successfully unlocks the door"
                    input "turnOnSwitches${user}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
                    input "turnOffSwitches${user}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true

                    paragraph title: "Do NOT run the above unlock actions under any of the following conditions", required: true, ""
                    input "runXPeopleUnlockActions${user}", "capability.presenceSensor", title: "...when any these people are present", required: false, multiple: true
                    input "runXModeUnlockActions${user}", "mode", title: "...when in any of these mode(s)", required: false, multiple: true

                    if (!user) { // Users will use the user notify option
                        paragraph "Get notifications when the door is unlocked manually (inside or outside)"
                        input "manualNotify", "bool", title: "Notify on manual unlock", submitOnChange: true
                        if (manualNotify) {
                            input "manualNotifyModes", "mode", title: "Only when in this mode(s) (optional)", required: false, multiple: true
                        }
                    }
                }

                section("Door Lock Actions (optional)") {
                    if (locks*.hasAttribute('invalidCode').contains(true)) { // For now only custom DH support lock codes
                        paragraph "Some locks (e.g. Schlage/Yale) can be locked from the keypad outside with a button. If your lock has his feature then you can assign routines to execute when it is locked with this button"
                        input "externalLockPhrase${user}", "enum", title: "Run routine on keypad lock", required: false, options: phrases
                        if (!user) { // Users will use the user notify option
                            input "externalLockNotify", "bool", title: "Notify on keypad lock", submitOnChange: true
                            if (externalLockNotify) {
                                input "externalLockNotifyModes", "mode", title: "Only when in this mode(s) (optional)", required: false, multiple: true
                            }
                        }
                        paragraph title: "Do NOT run the above lock actions under any of the following conditions", required: true, ""
                        input "runXPeopleLockActions${user}", "capability.presenceSensor", title: "...when any these people are present", required: false, multiple: true
                        input "runXModeLockActions${user}", "mode", title: "...when in any of these mode(s)", required: false, multiple: true
                    } else {
                        paragraph title: "Use the Enhanced Z-Wave Lock device handler to get access to lock specific actions", required: true, ""
                    }

                    if (!user) { // Users will use the user notify option
                        paragraph "Get notifications when the door is locked (manually or automatically)"
                        input "lockNotify", "bool", title: "Notify on manual lock", submitOnChange: true
                        if (lockNotify) {
                            input "lockNotifyModes", "mode", title: "Only when in this mode(s) (optional)", required: false, multiple: true
                        }

                        input "jamNotify", "bool", title: "Notify on Lock Jam/Stuck"
                    }
                }
            }
        }
    }
}

def usersPage() {
	dynamicPage(name:"usersPage", title: "User Names, Actions and Notification Setup", uninstall: true, install: true) {

        for (int i = 1; i <= settings.maxUserNames; i++) {
            def priorName = settings."userNames${i}"
            def priorNotify = settings."userNotify${i}"
            def priorNotifyModes = settings."userNotifyModes${i}"
            log.debug "Initial $i Name: $priorName, Notify: $priorNotify, NotifyModes: $priorNotifyModes"

            section("Slot #${i} User") {
                // User and code details/types
                input "userNames${i}", "text", description: "Tap to set", title: "Name", multiple: false, required: (settings."userCodes${i}" ? true : false), submitOnChange: true
                input "userNotify${i}", "bool", title: "Notify on use", defaultValue: "true", submitOnChange: true
                if (settings."userNotify${i}") {
                    input "userNotifyModes${i}", "mode", title: "...only when in this mode(s) (optional)", required: false, multiple: true
                    input "userXNotifyPresence${i}", "capability.presenceSensor", title: "...when these people are NOT present (optional)", required: false, multiple: true
                }

                if (priorName) {
                    // Unlock actions for each user
                    def hrefParams = [
                        user: i as String, 
                        passed: true 
                    ]
                    href(name: "unlockActions", params: hrefParams, title: "Click here to define custom actions for ${settings."userNames${i}"}", page: "unlockLockActionsPage", description: "", required: false)
                }
            }
        } 
    } 
}

def installed()
{
    log.debug "Install Settings: $settings"
    appTouch()
}

def updated()
{
    log.debug "Update Settings: $settings"
    appTouch()
}

def appTouch() {
    unschedule() // clear all pending updates
    unsubscribe()

    // Check for new versions of the code
    def random = new Random()
    Integer randomHour = random.nextInt(18-10) + 10
    Integer randomDayOfWeek = random.nextInt(7-1) + 1 // 1 to 7
    schedule("0 0 " + randomHour + " ? * " + randomDayOfWeek, checkForCodeUpdate) // Check for code updates once a week at a random day and time between 10am and 6pm
    
    // subscribe to random events to kick start timers again due to buggy platform killing the timers after a while
    subscribe(location, "mode", changeHandler)
    subscribe(location, "position", changeHandler)
    subscribe(location, "sunset", changeHandler)
    subscribe(location, "sunrise", changeHandler)
    subscribe(location, "routineExecuted", changeHandler)
    subscribe(app, changeHandler) // Capture user intent to reinitialize timers

    subscribe(locks, "lock", lockHandler) // Subscribe to lock events to take action as defined as user
    subscribe(locks, "tamper", lockHandler) // Subscribe to tamper events

    locks.each { lock -> // check each lock individually
        if (settings."sensor${lock}") {
            log.trace "Subscribing to sensor ${settings."sensor${lock}"} for ${lock}"
            subscribe(settings."sensor${lock}", "contact", sensorHandler)
        }
        if (lock.hasAttribute('invalidCode')) {
            log.trace "Found attribute 'invalidCode' on lock $lock, enabled support for invalid code detection"
            subscribe(lock, "invalidCode", lockHandler)
        }
    }

    atomicState.reLocks = [:] // List of lock to relock after a timed delay
    atomicState.notifyOpenDoors = [:] // List of locks to check for open notifications
    atomicState.immediateLocks = [] // List of lock to lock immediately after a short delay
    atomicState.unLocks = [] // List of lock to unlock after a short delay
}

// Handle changes, reinitialize the code check timers after a change, this is to workaround the issue of a buggy ST platform where the timers die randomly for some users
def changeHandler(evt) {
    log.trace "Reinitializing code check timer on event notification, name: ${evt?.name}, value: ${evt?.value}"
    
    if (evt?.name == "mode") { // Mode change notification
        for (lock in locks) { // Check all locks
            def sensor = settings."sensor${lock}" // Find the lock for this sensor, match by ID and not objects
            if (sensor) {
                log.trace "Checking for any pending door sensor activites that need to be done for lock $lock with sensor $sensor in mode ${evt.value}"
                def sensorEvt = [name: sensor.name, displayName: sensor.displayName, value: sensor.latestValue("contact"), device: sensor]
                sensorHandler(sensorEvt)
            }
        }
    }
}

def sensorHandler(evt) {
    log.trace "Event name $evt.name, value $evt.value, device $evt.displayName"

    def sensor = evt.device

    def lock = locks.find { settings."sensor${it}"?.id == sensor.id } // Find the lock for this sensor, match by ID and not objects
    log.debug "Sensor ${sensor} belongs to Lock ${lock}"

    if (evt.value == "closed") { // Door was closed
        if (lock && settings."relockDoor${lock}" && (settings."relockDoorModes${lock}" ? settings."relockDoorModes${lock}".find{it == location.mode} : true)) { // Are we asked to reLock this door
            if (settings."relockImmediate${lock}") {
                log.debug "Relocking ${lock} immediately in 3 seconds"
                def immediatelocks = atomicState.immediateLocks ?: [] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                if (!immediatelocks.contains(lock.id)) { // Don't re add the same lock again
                    //log.trace "Adding ${lock.id} to the list of immediate locks"
                    immediatelocks.add(lock.id) // Atomic to ensure we get upto date info here
                    atomicState.immediateLocks = immediatelocks // Set it back, we can't work direct on atomicState
                }
                immediateLockDoor() // Lock it right away
            } else if (settings."relockAfter${lock}") {
                log.debug "Scheduling ${lock} to lock in ${settings."relockAfter${lock}"} minutes"
                def reLocks = atomicState.reLocks ?: [:] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                //log.trace "Adding ${lock.id} to the list of relocks"
                reLocks[lock.id] = now() // Atomic to ensure we get upto date info here, Update and Add work the same way here so we don't need to check before adding/updating
                atomicState.reLocks = reLocks // Set it back, we can't work direct on atomicState
                reLockDoor() // Call relock door it'll take of delaying the lock as required
            } else {
                log.error "Invalid configuration, no relock timeout defined"
            }
        }
    } else { // Door was opened
        // Chime bell
        if (settings."openNotifyBeep${lock}") {
            if (!settings."openNotifyModes${lock}" || (location.modes?.find{it.name == settings."openNotifyModes${lock}"})) {
                log.debug "Door ${sensor} was opened, chiming bell ${settings."openNotifyBeep${lock}"}"
                settings."openNotifyBeep${lock}".beep() // Beep
            } else {
                log.trace "${lock} chiming not set for Mode ${location.mode}"
            }
        }

        // Notify user
        if (settings."openNotify${lock}") {
            if (!settings."openNotifyModes${lock}" || (location.modes?.find{it.name == settings."openNotifyModes${lock}"})) {
                log.debug "Scheduling ${lock} to notify user of open door in ${settings."openNotifyTimeout${lock}"} minutes"
                //log.trace "Updating ${lock.id} timestamp in the list of notifyOpenDoors"
                def notifyOpenDoors = atomicState.notifyOpenDoors ?: [:] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                notifyOpenDoors[lock.id] = now() // Atomic to ensure we get upto date info here, Update and Add work the same way here so we don't need to check before adding/updating
                atomicState.notifyOpenDoors = notifyOpenDoors // Set it back, we can't work direct on atomicState
                notifyOpenDoor() // Notify, it'll take of delaying it if it's too soon
            } else {
                log.trace "${lock} open notification not set for Mode ${location.mode}"
            }
        }
    }
}

// Check for any pending door unlocks
def unLockDoor() {
    def unLocksIDs = atomicState.unLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
    log.trace "Pending door unlocks ${unLocksIDs}"

    unLocksIDs?.each { lockid ->
        def lock = locks.find { it.id == lockid } // find the lock
        log.info "UnLocking the door ${lock} immediately"
        lock.unlock() // unlock it
        def unlocks = atomicState.unLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
        //log.trace "Removing ${lockid} from the list of pending unlocks"
        unlocks.remove(lockid) // We are done with this lock, remove it from the list
        atomicState.unLocks = unlocks // set it back to atomicState
        //log.trace "Checking for any pending door unlocks in 3 seconds"
        startTimer(3, unLockDoor) // Next immediate door lock in 3 seconds (give it some time for the mesh network)
        return // We're done here
    }
}

// Check for any pending immediate door locks
def immediateLockDoor() {
    def immediateLocksIDs = atomicState.immediateLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
    log.trace "Pending immediate door locks ${immediateLocksIDs}"

    immediateLocksIDs?.each { lockid ->
        def lock = locks.find { it.id == lockid } // find the lock
        log.info "Locking the door ${lock} immediately"
        lock.lock() // lock it
        def immediatelocks = atomicState.immediateLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
        //log.trace "Removing ${lockid} from the list of pending immediate locks"
        immediatelocks.remove(lockid) // We are done with this lock, remove it from the list
        atomicState.immediateLocks = immediatelocks // set it back to atomicState
        //log.trace "Checking for any pending immediate door locks in 3 seconds"
        startTimer(3, immediateLockDoor) // Next immediate door lock in 3 seconds (give it some time for the mesh network)
        return // We're done here
    }
}

// Check for any pending delayed door relocks
def reLockDoor() {
    def reLocksIDs = atomicState.reLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
    log.trace "Checking door sensor state and relocking ${reLocksIDs}"

    Long shortestPendingTime = 0 // in seconds
    
    reLocksIDs?.each { lockid, timestamp ->
        def lock = locks.find { it.id == lockid } // find the lock
        def lockSensor = settings."sensor${lock}" // Get the sensor for the lock
        Long timeLeft = (((60 * 1000 * settings."relockAfter${lock}") + timestamp) - now())/1000 // timestamp and now() is in ms
        if (timeLeft <= 1) { // If we are within 1 second then go ahead since the timer isn't always 100% accurate
            if (lockSensor.latestValue("contact") == "closed") {
                log.info "Sensor ${lockSensor} is reporting door ${lock} is closed, locking the door"
                lock.lock() // lock it
                //log.trace "Removing ${lockid} from the list of pending relocks"
                def reLocks = atomicState.reLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                reLocks.remove(lockid) // We are done with this lock, remove it from the list
                atomicState.reLocks = reLocks // set it back to atomicState
                //log.trace "Checking for any pending relocks in 3 seconds"
                startTimer(3, reLockDoor) // Next pending relock in 3 seconds (give it some time for the mesh network)
                return // We're done here
            } else {
                log.debug "Sensor ${lockSensor} is reporting door ${lock} is not closed, will check again in 60 seconds"
                startTimer(60, reLockDoor) // Check back again in some time
            }
        } else {
            log.trace "${lock} has not reached the time limit of ${settings."relockAfter${lock}"} minutes yet, ${timeLeft/60} minutes to go"
            if (!shortestPendingTime || (timeLeft < shortestPendingTime)) {
                log.trace "Settings shortest pending time to ${timeLeft} seconds"
                shortestPendingTime = timeLeft
            }
        }
    }
    
    if (shortestPendingTime) {
        startTimer((shortestPendingTime < 1 ? 1 : shortestPendingTime), reLockDoor) // Check back again after shortest pending timeout
    }
}

// Notify if the doors are left open
def notifyOpenDoor() {
    def notifyOpenDoorsIds = atomicState.notifyOpenDoors // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
    log.trace "Checking Locks ${notifyOpenDoorsIds} door sensor state"

    Long shortestPendingTime = 0 // in seconds
    
    notifyOpenDoorsIds?.each { lockid, timestamp ->
        def lock = locks.find { it.id == lockid } // find the lock
        def lockSensor = settings."sensor${lock}" // Get the sensor for the lock
        Long timeLeft = (((60 * 1000 * settings."openNotifyTimeout${lock}") + timestamp) - now())/1000 // timestamp and now() is in ms
        if (timeLeft <= 1) { // If we are within 1 second then go ahead since the timer isn't always 100% accurate
            if (lockSensor.latestValue("contact") == "closed") {
                log.debug "Sensor ${lockSensor} is reporting door ${lock} is closed, no notification required"
                //log.trace "Removing ${lockid} from the list of pending notifications"
                def notifyOpenDoors = atomicState.notifyOpenDoors // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                notifyOpenDoors.remove(lock.id) // We are done with this lock, remove it from the list
                atomicState.notifyOpenDoors = notifyOpenDoors // set it back to atomicState
            } else {
                log.info "Sensor ${lockSensor} is reporting door ${lock} is open, notifying user and checking again after ${settings."openNotifyTimeout${lock}"} minutes"
                def msg = "$lock has been open for ${settings."openNotifyTimeout${lock}"} minutes"

                //log.trace "Updating ${lock.id} timestamp in the list of notifyOpenDoors"
                def notifyOpenDoors = atomicState.notifyOpenDoors // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                notifyOpenDoors[lock.id] = now() // Atomic to ensure we get upto date info here
                atomicState.notifyOpenDoors = notifyOpenDoors // set it back to atomicState

                startTimer(60, notifyOpenDoor) // Check back again after short timeout so we don't overwrite a short wait with a long wait
                sendNotifications(msg) // Do it in the end to avoid a timeout
            }
        } else {
            log.trace "${lock} has not reached the time limit of ${settings."openNotifyTimeout${lock}"} minutes yet, ${timeLeft/60} minutes to go"
            if (!shortestPendingTime || (timeLeft < shortestPendingTime)) {
                log.trace "Settings shortest pending time to ${timeLeft} seconds"
                shortestPendingTime = timeLeft
            }
        }
    }
    
    if (shortestPendingTime) {
        startTimer((shortestPendingTime < 1 ? 1 : shortestPendingTime), notifyOpenDoor) // Check back again after shortest pending timeout
    }
}

def lockHandler(evt) {
    def data = null
    def lock = evt.device

    log.debug "Lock event name $evt.name, value $evt.value, device $evt.displayName, description $evt.descriptionText, data $evt.data"

    if (evt.name == "lock") { // LOCK UNLOCK EVENTS
        if (evt.value == "unlocked") { // UNLOCKED
            log.trace "Event name $evt.name, value $evt.value, device $evt.displayName"
            
            // Check if we have a sensor and delayed relock is enabled, if so then start the timer now just incase the user never opens the door
            def sensor = settings."sensor${lock}"
            if (sensor?.latestValue("contact") == "closed") { // Door is still closed
                log.trace "Found Sensor ${sensor} assigned to Lock ${lock} and it's still closed"

                if (settings."relockDoor${lock}" && settings."relockAfter${lock}" && (settings."relockDoorModes${lock}" ? settings."relockDoorModes${lock}".find{it == location.mode} : true)) { // Are we asked to reLock this door
                    log.debug "Scheduling ${lock} to lock in ${settings."relockAfter${lock}"} minutes"
                    def reLocks = atomicState.reLocks ?: [:] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                    //log.trace "Adding ${lock.id} to the list of relocks"
                    reLocks[lock.id] = now() // Atomic to ensure we get upto date info here, Update and Add work the same way here so we don't need to check before adding/updating
                    atomicState.reLocks = reLocks // Set it back, we can't work direct on atomicState
                    reLockDoor() // Call relock door it'll take of delaying the lock as required
                } else {
                    log.trace "No relock timeout defined, not scheduling relock"
                }
            }
            
            if (evt.data) { // Was it unlocked using a code
                data = new JsonSlurper().parseText(evt.data)
            }
            def lockMode = data?.type ?: (evt.descriptionText?.contains("manually") ? "manually" : "electronically")
            // Fix for proper grammar
            switch (lockMode) {
                case "manual":
                	lockMode = "manually"
                    break
                    
                case "rfid":
                	lockMode = "via rfid"
                    break
                    
                case "bluetooth":
                	lockMode = "via bluetooth"
                    break
                    
                case "keypad":
                	lockMode = "via keypad"
                    break
                    
                case "remote":
                	lockMode = "remotely"
                    break
                    
                case "auto":
                	lockMode = "via internal autolock"
                    break
                    
                default:
                    break
            }
            
            if ((data?.usedCode == null) && !(["keypad", "rfid"].any { lockMode?.contains(it) })) { // No extended data, must be a manual/auto/keyed unlock (don't run actions on manual lock/auto/unlock as it would run everything the knob/button is pressed from inside the house), some locks don't send keypad user codes
                log.debug "$evt.displayName was unlocked manually. Source type: $lockMode"

                if ((!settings."individualDoorActions" && manualNotify && (manualNotifyModes ? manualNotifyModes.find{it == location.mode} : true)) ||
                    (settings."individualDoorActions" && settings."manualNotify${lock}" && (settings."manualNotifyModes${lock}" ? settings."manualNotifyModes${lock}".find{it == location.mode} : true))) {
                    def msg = "$evt.displayName was unlocked $lockMode"
                    sendNotifications(msg)
                }
            } else {
                Integer i = data.usedCode as Integer
                def userName = settings."userNames${i}"
                def notify = settings."userNotify${i}"
                def notifyModes = settings."userNotifyModes${i}"
                def notifyXPresence = settings."userXNotifyPresence${i}"

                log.debug "Lock $evt.displayName unlocked by $userName, notify $notify, notify modes $notifyModes, notify NOT present $notifyXPresence, Source type: $lockMode"

                def msg = ""

                if (i == 0) {
                    userName = "Master Code" // Special case locks like Yale have a master code which isn't programmable and is code 0
                    notify = true // always inform about master users
                }
                
                if (userName == null) {
                    notify = true // always inform about unknown users
                    msg = "$evt.displayName was unlocked by Unknown User from slot $i $lockMode"
                } else {
                    msg = "$evt.displayName was unlocked by $userName $lockMode"
                }

                // Check if we have user override unlock actions defined
                def user = ""
                if (settings."userOverrideUnlockActions${i as String}") {
                    log.debug "Found per user unlock actions"
                    user = i as String
                }

                // First disarm SHM since it goes off due to other events
                if (settings."individualDoorActions${user}") {
                    if (settings."runXPeopleUnlockActions${lock}${user}"?.find{it.currentPresence == "present"}) {
                        log.debug "${settings."runXPeopleUnlockActions${lock}${user}"?.find{it.currentPresence == "present"}} is present, not running unlock actions for door $lock"
                    } else if (settings."runXModeUnlockActions${lock}${user}"?.find{it == location.mode}) {
                        log.debug "Current mode is ${location.mode}, not running unlock actions for door $lock"
                    } else {
                        if (settings."homeDisarm${lock}${user}") {
                            log.info "Disarming Smart Home Monitor"
                            sendLocationEvent(name: "alarmSystemStatus", value: "off") // First do this to avoid false alerts from a slow platform
                            msg += detailedNotifications ? ", disarming Smart Home Monitor" : ""
                        }

                        if (settings."homeMode${lock}${user}") {
                            log.info "Changing mode to ${settings."homeMode${lock}${user}"}"
                            if (location.modes?.find{it.name == settings."homeMode${lock}${user}"}) {
                                setLocationMode(settings."homeMode${lock}${user}") // First do this to avoid false alerts from a slow platform
                            }  else {
                                log.warn "Tried to change to undefined mode '${settings."homeMode${lock}${user}"}'"
                            }
                            msg += detailedNotifications ? ", changing mode to ${settings."homeMode${lock}${user}"}" : ""
                        }

                        if (settings."homePhrase${lock}${user}") {
                            log.info "Running unlock Phrase ${settings."homePhrase${lock}${user}"}"
                            location.helloHome.execute(settings."homePhrase${lock}${user}") // First do this to avoid false alerts from a slow platform
                            msg += detailedNotifications ? ", running routine ${settings."homePhrase${lock}${user}"}" : ""
                        }

                        if (settings."turnOnSwitchesAfterSunset${lock}${user}") {
                            def cdt = new Date(now())
                            def sunsetSunrise = getSunriseAndSunset(sunsetOffset: "-00:30") // Turn on 30 minutes before sunset (dark)
                            log.trace "Current DT: $cdt, Sunset $sunsetSunrise.sunset, Sunrise $sunsetSunrise.sunrise"
                            if ((cdt >= sunsetSunrise.sunset) || (cdt <= sunsetSunrise.sunrise)) {
                                log.info "$evt.displayName was unlocked successfully, turning on lights ${settings."turnOnSwitchesAfterSunset${lock}${user}"} since it's after sunset but before sunrise"
                                settings."turnOnSwitchesAfterSunset${lock}${user}"?.on()
                                msg += detailedNotifications ? ", turning on lights ${settings."turnOnSwitchesAfterSunset${lock}${user}"}" : ""
                            }
                        }

                        if (settings."turnOnSwitches${lock}${user}") {
                            log.info "$evt.displayName was unlocked successfully, turning on switches ${settings."turnOnSwitches${lock}${user}"}"
                            settings."turnOnSwitches${lock}${user}"?.on()
                            msg += detailedNotifications ? ", turning on switches ${settings."turnOnSwitches${lock}${user}"}" : ""
                        }

                        if (settings."turnOffSwitches${lock}${user}") {
                            log.info "$evt.displayName was unlocked successfully, turning off switches ${settings."turnOffSwitches${lock}${user}"}"
                            settings."turnOffSwitches${lock}${user}"?.off()
                            msg += detailedNotifications ? ", turning off switches ${settings."turnOffSwitches${lock}${user}"}" : ""
                        }
                    }
                } else {
                    if (settings."runXPeopleUnlockActions${user}"?.find{it.currentPresence == "present"}) {
                        log.debug "${settings."runXPeopleUnlockActions${user}"?.find{it.currentPresence == "present"}} is present, not running unlock actions"
                    } else if (settings."runXModeUnlockActions${user}"?.find{it == location.mode}) {
                        log.debug "Current mode is ${location.mode}, not running unlock actions"
                    } else {
                        if (settings."homeDisarm${user}") {
                            log.info "Disarming Smart Home Monitor"
                            sendLocationEvent(name: "alarmSystemStatus", value: "off") // First do this to avoid false alerts from a slow platform
                            msg += detailedNotifications ? ", disarming Smart Home Monitor" : ""
                        }

                        if (settings."homeMode${user}") {
                            log.info "Changing mode to ${settings."homeMode${user}"}"
                            if (location.modes?.find{it.name == settings."homeMode${user}"}) {
                                setLocationMode(settings."homeMode${user}") // First do this to avoid false alerts from a slow platform
                            }  else {
                                log.warn "Tried to change to undefined mode '${settings."homeMode${user}"}'"
                            }
                            msg += detailedNotifications ? ", changing mode to ${settings."homeMode${user}"}" : ""
                        }

                        if (settings."homePhrase${user}") {
                            log.info "Running unlock Phrase ${settings."homePhrase${user}"}"
                            location.helloHome.execute(settings."homePhrase${user}") // First do this to avoid false alerts from a slow platform
                            msg += detailedNotifications ? ", running routine ${settings."homePhrase${user}"}" : ""
                        }

                        if (settings."turnOnSwitchesAfterSunset${user}") {
                            def cdt = new Date(now())
                            def sunsetSunrise = getSunriseAndSunset(sunsetOffset: "-00:30") // Turn on 30 minutes before sunset (dark)
                            log.trace "Current DT: $cdt, Sunset $sunsetSunrise.sunset, Sunrise $sunsetSunrise.sunrise"
                            if ((cdt >= sunsetSunrise.sunset) || (cdt <= sunsetSunrise.sunrise)) {
                                log.info "$evt.displayName was unlocked successfully, turning on lights ${settings."turnOnSwitchesAfterSunset${user}"} since it's after sunset but before sunrise"
                                settings."turnOnSwitchesAfterSunset${user}"?.on()
                                msg += detailedNotifications ? ", turning on lights ${settings."turnOnSwitchesAfterSunset${user}"}" : ""
                            }
                        }

                        if (settings."turnOnSwitches${user}") {
                            log.info "$evt.displayName was unlocked successfully, turning on switches ${settings."turnOnSwitches${user}"}"
                            settings."turnOnSwitches${user}"?.on()
                            msg += detailedNotifications ? ", turning on switches ${settings."turnOnSwitches${user}"}" : ""
                        }

                        if (settings."turnOffSwitches${user}") {
                            log.info "$evt.displayName was unlocked successfully, turning off switches ${settings."turnOffSwitches${user}"}"
                            settings."turnOffSwitches${user}"?.off()
                            msg += detailedNotifications ? ", turning off switches ${settings."turnOffSwitches${user}"}" : ""
                        }
                    }
                }
                
                // Send notifications
                if (notify && (
                    (notifyModes ? notifyModes?.find{it == location.mode} : true) &&
                    (notifyXPresence ? notifyXPresence.every{it.currentPresence != "present"} : true)
                )) {
                    sendNotifications(msg)
                }
            }
        } else if (evt.value == "locked") { // LOCKED MANUALLY OR VIA KEYPAD OR ELECTRONICALLY
            log.debug "$evt.displayName was locked with description: $evt.descriptionText"
            
            def msgs = [] // Message to send

            if (evt.data) { // Was it locked using a user code
                data = new JsonSlurper().parseText(evt.data)
            }
            def lockMode = data?.type ?: (evt.descriptionText?.contains("manually") ? "manually" : "electronically")
            // Fix for proper grammar
            switch (lockMode) {
                case "manual":
                	lockMode = "manually"
                    break
                    
                case "rfid":
                	lockMode = "via rfid"
                    break
                    
                case "bluetooth":
                	lockMode = "via bluetooth"
                    break
                    
                case "keypad":
                	lockMode = "via keypad"
                    break
                    
                case "remote":
                	lockMode = "remotely"
                    break
                    
                case "auto":
                	lockMode = "via internal autolock"
                    break
                    
                default:
                    break
            }
            
            if ((["keypad", "rfid"].any { lockMode?.contains(it) }) || (data?.usedCode != null)) { // LOCKED VIA KEYPAD/RFID (keep compatibility for stock ST handler when lock codes are integrated)
                def user = ""
                def userName, notify, notifyModes, notifyXPresence, extLockNotify, extLockNotifyModes, userOverrideActions

                if (data?.usedCode >= 0) {
                    Integer i = data.usedCode as Integer

                    if (i == 0) {
                        userName = "Master Code" // Special case locks like Yale have a master code which isn't programmable and is code 0
                        notify = true // always inform about master users
                    } else {
                        user = i as String
                        userName = settings."userNames${i}"
                        notify = settings."userNotify${i}"
                        notifyModes = settings."userNotifyModes${i}"
                        notifyXPresence = settings."userXNotifyPresence${i}"
                        userOverrideActions = settings."userOverrideUnlockActions${i}"

                        // Check if we have user override lock actions defined
                        if (!settings."userOverrideUnlockActions${i}") {
                            log.trace "No user $userName specific lock action found, falling back to global actions"
                            user = "" // We don't have a user specific action defined, fall back to global actions
                        }
                    }
                } else {
                    log.trace "No usercode found in extended data for external user lock"
                }

                // Check if we have individual door actions defined (at user or global level)
                if (settings."individualDoorActions${user}") {
                    extLockNotify = settings."externalLockNotify${lock}"
                    extLockNotifyModes = settings."externalLockNotifyModes${lock}"
                } else {
                    extLockNotify = settings."externalLockNotify"
                    extLockNotifyModes = settings."externalLockNotifyModes"
                }

                log.trace "Lock $evt.displayName locked by $userName, user notify $notify, user notify modes $notifyModes, notify NOT present $notifyXPresence, external notify $extLockNotify, external notify modes $extLockNotifyModes, user override action $userOverrideActions, Source type: $lockMode"

                def msg = "$evt.displayName was locked ${userName ? "by " + userName + " " : ""}$lockMode" // Default message to send

                if (settings."individualDoorActions${user}") {
                    if (settings."runXPeopleLockActions${lock}${user}"?.find{it.currentPresence == "present"}) {
                        log.debug "${settings."runXPeopleLockActions${lock}${user}"?.find{it.currentPresence == "present"}} is present, not running lock actions for door $lock"
                    } else if (settings."runXModeLockActions${lock}${user}"?.find{it == location.mode}) {
                        log.debug "Current mode is ${location.mode}, not running lock actions for door $lock"
                    } else {
                        if (settings."externalLockPhrase${lock}${user}") {
                            log.info "Running $lock specific locked Phrase ${settings."externalLockPhrase${lock}${user}"} for ${userName ?: "external lock"}"
                            location.helloHome.execute(settings."externalLockPhrase${lock}${user}") // First do this to avoid false alerts from a slow platform
                            msg += detailedNotifications ? ", running ${settings."externalLockPhrase${lock}${user}"}" : ""
                        } else {
                            log.trace "No individual routine configured to run when locked $lockMode for $lock"
                        }
                    }
                } else {
                    if (settings."runXPeopleLockActions${user}"?.find{it.currentPresence == "present"}) {
                        log.debug "${settings."runXPeopleLockActions${user}"?.find{it.currentPresence == "present"}} is present, not running lock actions"
                    } else if (settings."runXModeLockActions${user}"?.find{it == location.mode}) {
                        log.debug "Current mode is ${location.mode}, not running lock actions"
                    } else {
                        if (settings."externalLockPhrase${user}") {
                            log.info "Running locked Phrase ${settings."externalLockPhrase${user}"} for ${userName ?: "external lock"}"
                            location.helloHome.execute(settings."externalLockPhrase${user}") // First do this to avoid false alerts from a slow platform
                            msg += detailedNotifications ? ", running ${settings."externalLockPhrase${user}"}" : ""
                        } else {
                            log.trace "No generic routine configured to run when locked $lockMode for $lock"
                        }
                    }
                }

                // Send a notification if required (message would be updated)
                if ((user && notify && (
                    			(notifyModes ? notifyModes.find{it == location.mode} : true) &&
                    			(notifyXPresence ? notifyXPresence.every{it.currentPresence != "present"} : true)
                			)) ||
                    (extLockNotify && (extLockNotifyModes ? extLockNotifyModes.find{it == location.mode} : true))) {
                    msgs << msg
                }
            }

            // Check if we need to retract a deadbolt lock it was locked while the door was still open
            if (settings."retractDeadbolt${lock}") {
                def sensor = settings."sensor${lock}"
                if (sensor.latestValue("contact") == "open") {
                    if (lock.hasAttribute('autolock') && (lock.latestValue("autolock") == "enabled")) { // Do not unlock if autolock features on the lock are enabled, avoid infinite loop
                        def msg = "Unlock on door open will NOT work while the AutoLock feature is enabled on $lock lock to avoid an infinite loop to locking/unlocking"
                        log.warn msg
                        msgs << msg
                    } else {
                        log.debug "$lock was locked while the door was still open, unlocking it in 10 seconds"
                        def unlocks = atomicState.unLocks ?: [] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                        if (!unlocks.contains(lock.id)) { // Don't re add the same lock again
                            //log.trace "Adding ${lock.id} to the list of unlocks"
                            unlocks.add(lock.id) // Atomic to ensure we get upto date info here
                            atomicState.unLocks = unlocks // Set it back, we can't work direct on atomicState
                        }
                        startTimer(10, unLockDoor) // Schedule the unlock in 10 seconds since the door may have just locked and avoid Z-Wave conflict and some locks like Schlage deadbolt have timing limitations which cause a busy conflict if done too soon
                    }
                } else {
                    log.trace "$lock was locked while the door was closed, we're good"
                }
            }

            if ((!settings."individualDoorActions" && lockNotify && (!(["keypad", "rfid"].any { lockMode?.contains(it) })) && (lockNotifyModes ? lockNotifyModes.find{it == location.mode} : true)) ||
                    (settings."individualDoorActions" && settings."lockNotify${lock}" && (!(["keypad", "rfid"].any { lockMode?.contains(it) })) && (settings."lockNotifyModes${lock}" ? settings."lockNotifyModes${lock}".find{it == location.mode} : true))) { // For manual and electronic locking only, keypad is handled above
                def msg = "$evt.displayName was locked $lockMode"
                msgs << msg
            }

            // Last thing to do because it can timeout
            for (msg in msgs) {
                sendNotifications(msg)
            }
        } else if (evt.value == "unknown") { // JAMMED CODE EVENT
            log.debug "Lock $evt.displayName Jammed!"
            if ((!settings."individualDoorActions" && jamNotify) ||
                (settings."individualDoorActions" && settings."jamNotify${lock}")) {
                def msg = "$evt.displayName lock is Jammed!"
                sendNotifications(msg)
            }        	
        }
    } else if (evt.name == "invalidCode") { // INVALID LOCK CODE EVENT
        log.debug "Lock $evt.displayName, invalid user code: ${evt.value}"
        def msg = "Too many invalid user codes detected on lock $evt.displayName"
        sendNotifications(msg)
    } else if (evt.name == "tamper" && evt.value == "detected") { // Tampering of the lock
        log.debug "Lock $evt.displayName tamper detected with description $evt.descriptionText"
        def msg = "Tampering detected on lock $evt.displayName. ${evt.descriptionText ?: ""}"
        sendNotifications(msg)
    }
}
                
def startTimer(seconds, function) {
    log.trace "Scheduled to run $function in $seconds seconds"

    //def runTime = new Date(now() + ((Long)seconds * 1000)) // for runOnce
    //runOnce(runTime, function, [overwrite: true]) // runIn isn't reliable, runOnce is more reliable but isn't as accurate
    runIn(seconds, function, [overwrite: true]) // runOnce is having issues with v2 hubs, hopefully runIn is more stable
}

private sendText(number, message) {
	if (number) {
    	def phones = number.split("\\*")
        for (phone in phones) {
            sendSms(phone, message)
        }
    }
}

private void sendNotifications(message) {
    if (location.contactBookEnabled) {
        sendNotificationToContacts(message, recipients)
    } else {
        if (!disableAllNotify) {
            sendPush message
        } else {
            sendNotificationEvent(message)
        }
        if (sms) {
            sendText(sms, message)
        }
    }
    if (audioDevices) {
        audioDevices*.playText(message)
    }
}

def checkForCodeUpdate(evt) {
    log.trace "Getting latest version data from the RBoy Apps server"
    
    def appName = "User Unlock Lock Door Notifications and Actions"
    def serverUrl = "http://smartthings.rboyapps.com"
    def serverPath = "/CodeVersions.json"
    
    try {
        httpGet([
            uri: serverUrl,
            path: serverPath
        ]) { ret ->
            log.trace "Received response from RBoy Apps Server, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //ret.headers.each {
            //    log.trace "${it.name} : ${it.value}"
            //}

            if (ret.data) {
                log.trace "Response>" + ret.data
                
                // Check for app version updates
                def appVersion = ret.data?."$appName"
                if (appVersion > clientVersion()) {
                    def msg = "New version of app ${app.label} available: $appVersion, current version: ${clientVersion()}.\nPlease visit $serverUrl to get the latest version."
                    log.info msg
                    if (!disableUpdateNotifications) {
                        sendPush(msg)
                    }
                } else {
                    log.trace "No new app version found, latest version: $appVersion"
                }
                
                // Check device handler version updates
                def devices = locks?.findAll { it.hasAttribute("codeVersion") }
                for (device in devices) {
                    if (device) {
                        def deviceName = device?.currentValue("dhName")
                        def deviceVersion = ret.data?."$deviceName"
                        if (deviceVersion && (deviceVersion > device?.currentValue("codeVersion"))) {
                            def msg = "New version of device ${device?.displayName} available: $deviceVersion, current version: ${device?.currentValue("codeVersion")}.\nPlease visit $serverUrl to get the latest version."
                            log.info msg
                            if (!disableUpdateNotifications) {
                                sendPush(msg)
                            }
                        } else {
                            log.trace "No new device version found for $deviceName, latest version: $deviceVersion, current version: ${device?.currentValue("codeVersion")}"
                        }
                    }
                }
            } else {
                log.error "No response to query"
            }
        }
    } catch (e) {
        log.error "Exception while querying latest app version: $e"
    }
}